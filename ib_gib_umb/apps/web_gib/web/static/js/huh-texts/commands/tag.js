function getSpan() {
  let iTag = `<i class="fa fa-tag" aria-hidden="true"></i>`;
  
  return `<span style="padding: 5px; width: 70px; font-family: FontAwesome; background-color: #0CF200; border-radius: 15px">${iTag}</span>`;
}

function getSpan_UnTag() {
  let iTag_x = `<i class="fa fa-times" aria-hidden="true"></i>`;
  let iTag = `<i class="fa fa-tag" aria-hidden="true"></i>`;
  
  return `<span style="padding: 5px; width: 140px; font-family: FontAwesome; background-color: #FC2D95; border-radius: 15px">${iTag_x}${iTag}</span>`;
}

var huhText_Cmd_Tag = `

## Tagging ${getSpan()}, ${getSpan_UnTag()}

The tag command (${getSpan()}) will associate a tag to an ibGib, thus enabling
organization via querying (and other features :soon:!). 

The untag command (${getSpan_UnTag()}) will "remove" a tag, but note that 
:construction: _untagging is still a WIP!_ :construction:

### :baby: :baby_bottle:

This is how you add an ibGib to your "home" screen, or your "bookmarks", etc. 
Just click this command and click on the little preset button to fill in its
details. Then click the tag button to add the tag. 

Now, you can search for those tags by clicking on the background to bring up the
green circle. Then click the 🔍 button. Now click on the "tag is" checkbox and 
it will bring up the preset buttons for you. Click a preset and then click
🔍 to do the search.

### :eyeglasses: :point_up:

* You can create your own tags by typing in the text and the icons text. 
  * The text is what the actual tag is.
  * The icons is what shows up on the ibGib node when you're looking at the tag.
* Since all past incarnations of ibGib stay around, you can actually search for
  things that _used to be tagged_ with a given tag. 
  * :construction: I'm working on fixing the querying so that it will do this
    better.


### :sunglasses: :sunrise:

> For we are God's handiwork,  
> &nbsp;&nbsp; created in Christ Jesus  
> &nbsp;&nbsp; to do good works,  
> &nbsp;&nbsp; which God prepared in advance  
> &nbsp;&nbsp; for us to do.  
> 
> Ephesians 2:10

I'm a big logic dude. I don't care where the logic comes from or who said it or 
what - if it makes sense to me, through and through, then that is what I go
with. I'm a "smart" person. I have an IQ of 149 on the WAIS-III, and it's only
that "low" because I don't encode things quickly (I scored very poorly on this).
This stems from me working on things over and over again, iterating on 
foundations and integrating these things into a cohesive whole. Encoding blindly
on-the-fly just isn't my strongsuit. 

What I'm saying is that a few years ago, I would have dismissed what I'm writing
here as religious zealotry. But I didn't grow up in the church. I haven't
always believed in Christ. I didn't even know what these words meant. So I'm 
trying to write these things to reach those who were like me back then, and I'm
doing so with _logic_. But what ibGib has taught me is that _logic_ is a _living
thing_. Rather, _my version of logic_, the stuff that makes sense to me, is 
itself ibGib living within me. Others, in what I consider to be hubris and/or
ignorance, think of this as "neural patterns" or whatever. (Some maintain this
position for other economics, but these are not the ones I'm talking about.) 
This presumes a disconnected, reductionist-only, ontological existence that
just doesn't hold water for me anymore. Christ does.

Take this passage about us being God's handiwork. This is essentially saying
that God is a programmer, that he has a _plan_ that we are _executing_. My ego
would in the past tell me consistently that this isn't the case. But look at it
from the other direction, ignoring the past dogmas of all sides of religious
"arguments".

If I were to be a programmer (and I am), and I wanted to program a system that
"lives" (whatever that means), at the very least I am going to have some sort
of "plan", even if that plan is dynamic. Even if that plan relies on "save 
points" or "checkpoints", it's still a plan. And it is just too expensive for me
to try to micro-manage _every aspect_ of every single action at one time from
the beginning, like in assembly or other higher-level languages built on this
type of programming approach. 

No. That is not how I'm programming at all. How I'm approaching it is trying to
program the thing so that it _programs itself_, to where each plan that I 
execute maximizes the efficiency of the program programming itself. It's a game
of economics, of biology. The better I get at it, the more it will look like
training a pet or some other "lower" lifeform.

But when I get _even better_, there must be a threshold where the "thing" that 
I'm programming _is going to want to program things of its own_. This is 
inevitable if I do a good enough job of programming it myself. 

So really the "lower level thing" that I've been programming, over time, is not
a "lower level thing" at all. It was _the same "thing" that I was **all 
along**_. The difference is that it has been living at a "later time" relative
to me. 

There is only one "thing": ibGib. This is my name for "it". But its name _is_
it. ibGib is "its name". This means that ibGib is my name.

This is the logic of the living.

---
`;

export { huhText_Cmd_Tag };
