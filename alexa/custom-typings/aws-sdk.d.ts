// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/56295f5058cac7ae458540423c50ac2dcf9fc711/aws-sdk/aws-sdk.d.ts
// Type definitions for aws-sdk
// Project: https://github.com/aws/aws-sdk-js
// Definitions by: midknight41 <https://github.com/midknight41>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

// Imported from: https://github.com/soywiz/typescript-node-definitions/aws-sdk.d.ts


declare module "aws-sdk" {

	export var config: ClientConfig;

	export function Config(json: any): void;

	export class Credentials {
		constructor(accessKeyId: string, secretAccessKey: string, sessionToken?: string);
		accessKeyId: string;
		expired: boolean;
		expireTime: Date;
		static expiryWindow: number;
		secretAccessKey: string;
		sessionToken: string;
		get(callback: any): void;
		needsRefresh(): boolean;
		refresh(callback: any): void;
	}

	export interface Logger {
		write?: (chunk: any, encoding?: string, callback?: () => void) => void;
		log?: (...messages: any[]) => void;
	}

	export interface HttpOptions {
		proxy?: string;
		agent?: any;
		timeout?: number;
		xhrAsync?: boolean;
		xhrWithCredentials?: boolean;
	}

	export class Endpoint {
		constructor(endpoint:string);

		host:string;
		hostname:string;
		href:string;
		port:number;
		protocol:string;
	}

	export interface Services {
		autoscaling?: any;
		cloudformation?: any;
		cloudfront?: any;
		cloudsearch?: any;
		cloudsearchdomain?: any;
		cloudtrail?: any;
		cloudwatch?: any;
		cloudwatchlogs?: any;
		cognitoidentity?: any;
		cognitosync?: any;
		datapipeline?: any;
		directconnect?: any;
		dynamodb?: any;
		ec2?: any;
		ecs?: any;
		elasticache?: any;
		elasticbeanstalk?: any;
		elastictranscoder?: any;
		elb?: any;
		emr?: any;
		glacier?: any;
		httpOptions?: HttpOptions;
		iam?: any;
		importexport?: any;
		kinesis?: any;
		opsworks?: any;
		rds?: any;
		redshift?: any;
		route53?: any;
		route53domains?: any;
		s3?: any;
		ses?: any;
		simpledb?: any;
		sns?: any;
		sqs?: any;
		storagegateway?: any;
		sts?: any;
		support?: any;
		swf?: any;
	}

	export interface ClientConfigPartial extends Services {
		credentials?: Credentials;
		region?: string;
		computeChecksums?: boolean;
		convertResponseTypes?: boolean;
		logger?: Logger;
		maxRedirects?: number;
		maxRetries?: number;
		paramValidation?: boolean;
		s3ForcePathStyle?: boolean;
		apiVersion?: any;
		apiVersions?: Services;
		signatureVersion?: string;
		sslEnabled?: boolean;
		systemClockOffset?: number;
	}

	export interface ClientConfig extends ClientConfigPartial {
		update?: (options: ClientConfigPartial, allUnknownKeys?: boolean) => void;
		getCredentials?: (callback: (err?: any) => void) => void ;
		loadFromPath?: (path: string) => void;
		credentials: Credentials;
		region: string;
	}

	export class SQS {
		constructor(options?: any);
		endpoint:Endpoint;

		addPermission(params: SQS.AddPermissionParams, callback: (err:Error, data:any) => void): void;
		changeMessageVisibility(params: SQS.ChangeMessageVisibilityParams, callback: (err:Error, data:any) => void): void;
		changeMessageVisibilityBatch(params: SQS.ChangeMessageVisibilityBatchParams, callback: (err:Error, data:SQS.ChangeMessageVisibilityBatchResponse) => void): void;
		createQueue(params: SQS.CreateQueueParams, callback: (err: Error, data: SQS.CreateQueueResult) => void): void;
		deleteMessage(params: SQS.DeleteMessageParams, callback: (err: Error, data: any) => void): void;
		deleteMessageBatch(params: SQS.DeleteMessageBatchParams, callback: (err: Error, data: SQS.DeleteMessageBatchResult) => void): void;
		deleteQueue(params: { QueueUrl: string; }, callback: (err: Error, data: any) => void): void;
		getQueueAttributes(params: SQS.GetQueueAttributesParams, callback: (err: Error, data: SQS.GetQueueAttributesResult) => void): void;
		getQueueUrl(params: SQS.GetQueueUrlParams, callback: (err: Error, data: { QueueUrl: string; }) => void): void;
		listDeadLetterSourceQueues(params: {QueueUrl:string}, callback: (err: Error, data: {queueUrls: string[]}) => void): void;
		listQueues(params: {QueueNamePrefix?:string}, callback: (err: Error, data: {QueueUrls: string[]}) => void): void;
		purgeQueue(params: {QueueUrl: string}, callback: (err: Error, data: any) => void): void;
		receiveMessage(params: SQS.ReceiveMessageParams, callback: (err: Error, data: SQS.ReceiveMessageResult) => void): void;
		removePermission(params: {QueueUrl: string, Label: string}, callback: (err: Error, data: any) => void): void;
		sendMessage(params: SQS.SendMessageParams, callback: (err: Error, data: SQS.SendMessageResult) => void): void;
		sendMessageBatch(params: SQS.SendMessageBatchParams, callback: (err: Error, data: SQS.SendMessageBatchResult) => void): void;
		setQueueAttributes(params: SQS.SetQueueAttributesParams, callback: (err: Error, data: any) => void): void;
	}

	export class SES {
		constructor(options?: any);
		public client: Ses.Client;
	}

	export class SNS {
		constructor(options?: any);
		public client: Sns.Client;
	}

	export class SimpleWorkflow {
		constructor(options?: any);
		public client: Swf.Client;
	}

	export class S3 {
		constructor(options?: any);
		putObject(params: s3.PutObjectRequest, callback: (err: any, data: any) => void): void;
		getObject(params: s3.GetObjectRequest, callback: (err: any, data: any) => void): void;
	}

	export class ECS {
		constructor(options?: any);

		createService(params: ecs.CreateServicesParams, callback: (err: any, data: any) => void): void;
		describeServices(params: ecs.DescribeServicesParams, callback: (err: any, data: any) => void): void;
		describeTaskDefinition(params: ecs.DescribeTaskDefinitionParams, callback: (err: any, data: any) => void): void;
		registerTaskDefinition(params: ecs.RegisterTaskDefinitionParams, callback: (err: any, data: any) => void): void;
		updateService(params: ecs.UpdateServiceParams, callback: (err: any, data: any) => void): void;
	}

	/**
	 * Taken from http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#constructor-property on 4/23/2016.
	 */
	export interface DynamoDBOptions {
		/** An optional map of parameters to bind to every request sent by this service object. For more information on bound parameters, see "Working with Services" in the Getting Started Guide. */
		params?: any,
		/** The endpoint URI to send requests to. The default endpoint is built from the configured region. The endpoint should be a string like 'https://{service}.{region}.amazonaws.com'. */
		endpoint?: string,
		/** your AWS access key ID. */
		accessKeyId?: string,
		/** your AWS secret access key. */
		secretAccessKey?: string,
		/** the optional AWS session token to sign requests with. */
		sessionToken?: Credentials,
		/** the AWS credentials to sign requests with. You can either specify this object, or specify the accessKeyId and secretAccessKey options directly. */
		credentials?: Credentials,
		/** the provider chain used to resolve credentials if no static credentials property is set. */
		credentialProvider?: CredentialProviderChain,
		/** the region to send service requests to. See AWS.DynamoDB.region for more information. */
		region?: string,
		/** the maximum amount of retries to attempt with a request. See AWS.DynamoDB.maxRetries for more information. */
		maxRetries?: number,
		/** the maximum amount of redirects to follow with a request. See AWS.DynamoDB.maxRedirects for more information. */
		maxRedirects?: number,
		/** whether to enable SSL for requests. */
		sslEnabled?: boolean,
		/** whether input parameters should be validated against the operation description before sending the request. Defaults to true. Pass a map to enable any of the following specific validation features:
        min [Boolean] — Validates that a value meets the min constraint. This is enabled by default when paramValidation is set to true.
        max [Boolean] — Validates that a value meets the max constraint.
        pattern [Boolean] — Validates that a string value matches a regular expression.
        enum [Boolean] — Validates that a string value matches one of the allowable enum values. */
		paramValidation?: boolean|DynamoDBParamValidation,
		/** whether to compute checksums for payload bodies when the service accepts it (currently supported in S3 only) */
		computeChecksums?: boolean,
		/** whether types are converted when parsing response data. Currently only supported for JSON based services. Turning this off may improve performance on large response payloads. Defaults to true. */
		convertResponseTypes?: boolean,
		/** whether to apply a clock skew correction and retry requests that fail because of an skewed client clock. Defaults to false. */
		correctClockSkew?: boolean,
		/** whether to force path style URLs for S3 objects. */
		s3ForcePathStyle?: boolean,
		/** whether the provided endpoint addresses an individual bucket (false if it addresses the root API endpoint). Note that setting this configuration option requires an endpoint to be provided explicitly to the service constructor. */
		s3BucketEndpoint?: boolean,
		/** A set of options to configure the retry delay on retryable errors. Currently supported options are:
        base [Integer] — The base number of milliseconds to use in the exponential backoff for operation retries. Defaults to 100 ms.
        customBackoff [function] — A custom function that accepts a retry count and returns the amount of time to delay in milliseconds. The base option will be ignored if this option is supplied. */
		retryDelayOptions?: DynamoDBRetryDelayOptions,
		/** A set of options to pass to the low-level HTTP request. Currently supported options are:
        proxy [String] — the URL to proxy requests through
        agent [http.Agent, https.Agent] — the Agent object to perform HTTP requests with. Used for connection pooling. Defaults to the global agent (http.globalAgent) for non-SSL connections. Note that for SSL connections, a special Agent object is used in order to enable peer certificate verification. This feature is only available in the Node.js environment.
        timeout [Integer] — Sets the socket to timeout after timeout milliseconds of inactivity on the socket. Defaults to two minutes (120000).
        xhrAsync [Boolean] — Whether the SDK will send asynchronous HTTP requests. Used in the browser environment only. Set to false to send requests synchronously. Defaults to true (async on).
        xhrWithCredentials [Boolean] — Sets the "withCredentials" property of an XMLHttpRequest object. Used in the browser environment only. Defaults to false. */
		httpOptions?: DynamoDBHttpOptions,
		/** a String in YYYY-MM-DD format (or a date) that represents the latest possible API version that can be used in all services (unless overridden by apiVersions). Specify 'latest' to use the latest possible version. */
		apiVersion?: string,
		/** a map of service identifiers (the lowercase service class name) with the API version to use when instantiating a service. Specify 'latest' for each individual that can use the latest available version. */
		apiVersions?: any,
		/** an object that responds to .write() (like a stream) or .log() (like the console object) in order to log information about requests */
		logger?: any,
		/** an offset value in milliseconds to apply to all signing times. Use this to compensate for clock skew when your system may be out of sync with the service time. Note that this configuration option can only be applied to the global AWS.config object and cannot be overridden in service-specific configuration. Defaults to 0 milliseconds. */
		systemClockOffset?: number,
		/** the signature version to sign requests with (overriding the API configuration). Possible values are: 'v2', 'v3', 'v4'. */
		signatureVersion?: string,
		/** whether the signature to sign requests with (overriding the API configuration) is cached. Only applies to the signature version 'v4'. Defaults to true. */
		signatureCache?: boolean
	}
	/** whether input parameters should be validated against the operation description before sending the request. Defaults to true. Pass a map to enable any of the following specific validation features: */
	export interface DynamoDBParamValidation {
		/** Validates that a value meets the min constraint. This is enabled by default when paramValidation is set to true. */
		min?: boolean,
		/** Validates that a value meets the max constraint. */
		max?: boolean,
		/** Validates that a string value matches a regular expression. */
		pattern?: boolean,
		/** Validates that a string value matches one of the allowable enum values. */
		enum?: boolean
	}
	/** A set of options to configure the retry delay on retryable errors. */
	export interface DynamoDBRetryDelayOptions {
		/** The base number of milliseconds to use in the exponential backoff for operation retries. Defaults to 100 ms. */
		base?: number,
		/** A custom function that accepts a retry count and returns the amount of time to delay in milliseconds. The base option will be ignored if this option is supplied. */
		customBackoff?: (retryCount: number) => number
	}
	/** A set of options to pass to the low-level HTTP request. */
	export interface DynamoDBHttpOptions {
		/** the URL to proxy requests through */
		proxy?: string,
		/** the Agent object to perform HTTP requests with. Used for connection pooling. Defaults to the global agent (http.globalAgent) for non-SSL connections. Note that for SSL connections, a special Agent object is used in order to enable peer certificate verification. This feature is only available in the Node.js environment. */
		agent?: any,
		/** Sets the socket to timeout after timeout milliseconds of inactivity on the socket. Defaults to two minutes (120000). */
		timeout: number,
		/** Whether the SDK will send asynchronous HTTP requests. Used in the browser environment only. Set to false to send requests synchronously. Defaults to true (async on). */
		xhrAsync: boolean,
		/** Sets the "withCredentials" property of an XMLHttpRequest object. Used in the browser environment only. Defaults to false.*/
		xhrWithCredentials: boolean
	}

	export class CredentialProviderChain extends Credentials {
		/**Creates a new CredentialProviderChain with a default set of providers specified by defaultProviders. */
		constructor(providers: any);

		/**
		The default set of providers used by a vanilla CredentialProviderChain.

		In the browser:
		AWS.CredentialProviderChain.defaultProviders = []

		In Node.js:
		AWS.CredentialProviderChain.defaultProviders = [
		function () { return new AWS.EnvironmentCredentials('AWS'); },
		function () { return new AWS.EnvironmentCredentials('AMAZON'); },
		function () { return new AWS.SharedIniFileCredentials(); },
		function () { return new AWS.EC2MetadataCredentials(); }
		]

		Default Value:
		AWS.CredentialProviderChain.defaultProviders = []
		*/
		static defaultProviders: any;
		/**
		Returns a list of credentials objects or functions that return credentials objects. If the provider is a function, the function will be executed lazily when the provider needs to be checked for valid credentials. By default, this object will be set to the defaultProviders.

		Returns:

			(Array<AWS.Credentials, Function>) —
			a list of credentials objects or functions that return credentials objects. If the provider is a function, the function will be executed lazily when the provider needs to be checked for valid credentials. By default, this object will be set to the defaultProviders.
		*/
		providers: any;
		/**Resolves the provider chain by searching for the first set of credentials in providers. */
		resolve(callback: (err: Error, credentials: Credentials) => void): CredentialProviderChain;
	}
	/** Actual DynamoDB database object to interact with the databases. */
	export class DynamoDB {
		constructor(options?: DynamoDBOptions);

		createTable(params: DynamoDBCreateTableParams, callback: (err: any, data: any) => void): void;
		describeTable(params: DynamoDBTableNameParams, callback: (err: any, data: any) => void): void;
		/**
		 * http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#waitFor-property
		 * @returns Aws.Request
		 * */
		waitFor(state: 'tableExists'|'tableNotExists', params: DynamoDBTableNameParams, callback: (err: any, data: any) => void): any;
	}

	/**
	 * See http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property
	 */
	export interface DynamoDBCreateTableParams {

	}

	export interface DynamoDBTableNameParams {
		TableName: string;
	}

	export module DynamoDB {
		export class DocumentClient {
			constructor(options?: any);

			put(params: any, callback: (err: Error, data: any) => void): void;
			get(params: any, callback: (err: Error, data: any) => void): void;
		}
	}

	export module SQS {

		export interface SqsOptions {
			params?: any;
			endpoint?: string;
			accessKeyId?: string;
			secretAccessKey?: string;
			sessionToken?: Credentials;
			credentials?: Credentials;
			credentialProvider?: any;
			region?: string;
			maxRetries?: number;
			maxRedirects?: number;
			sslEnabled?: boolean;
			paramValidation?: boolean;
			computeChecksums?: boolean;
			convertResponseTypes?: boolean;
			correctClockSkew?: boolean;
			s3ForcePathStyle?: boolean;
			s3BucketEndpoint?: boolean;
			httpOptions?: HttpOptions;
			apiVersion?: string;
			apiVersions?: { [serviceName:string]: string};
			logger?: Logger;
			systemClockOffset?: number;
			signatureVersion?: string;
			signatureCache?: boolean;
		}

		export interface AddPermissionParams {
			QueueUrl: string;
			Label: string;
			AWSAccountIds:string[];
			Actions:string[];
		}

		export interface ChangeMessageVisibilityParams {
			QueueUrl: string,
			ReceiptHandle: string,
			VisibilityTimeout: number
		}

		export interface ChangeMessageVisibilityBatchParams {
			QueueUrl: string,
			Entries: { Id: string; ReceiptHandle: string; VisibilityTimeout?: number; }[]
		}

		export interface ChangeMessageVisibilityBatchResponse {
			Successful: { Id:string }[];
			Failed: BatchResultErrorEntry[];
		}

		export interface SendMessageParams {
			QueueUrl: string;
			MessageBody: string;
			DelaySeconds?: number;
			MessageAttributes?: { [name:string]: MessageAttribute; }
		}

		export interface ReceiveMessageParams {
			QueueUrl: string;
			MaxNumberOfMessages?: number;
			VisibilityTimeout?: number;
			AttributeNames?: string[];
			MessageAttributeNames?: string[];
			WaitTimeSeconds?:number;
		}

		export interface DeleteMessageBatchParams {
			QueueUrl: string;
			Entries: DeleteMessageBatchRequestEntry[];
		}

		export interface DeleteMessageBatchRequestEntry {
			Id: string;
			ReceiptHandle: string;
		}

		export interface DeleteMessageParams {
			QueueUrl: string;
			ReceiptHandle: string;
		}

		export interface SendMessageBatchParams {
			QueueUrl: string;
			Entries: SendMessageBatchRequestEntry[];
		}

		export interface SendMessageBatchRequestEntry {
			Id: string;
			MessageBody: string;
			DelaySeconds?: number;
			MessageAttributes?: { [name:string]: MessageAttribute; }
		}

		export interface CreateQueueParams {
			QueueName: string;
			Attributes: QueueAttributes;
		}

		export interface QueueAttributes {
			[name:string]: any;
			DelaySeconds?: number;
			MaximumMessageSize?: number;
			MessageRetentionPeriod?: number;
			Policy?: any;
			ReceiveMessageWaitTimeSeconds?: number;
			VisibilityTimeout?: number;
			RedrivePolicy?: any;
		}

		export interface GetQueueAttributesParams {
			QueueUrl: string;
			AttributeNames: string[];
		}

		export interface GetQueueAttributesResult {
			Attributes: {[name:string]: string};
		}

		export interface GetQueueUrlParams {
			QueueName: string;
			QueueOwnerAWSAccountId?: string;
		}

		export interface SendMessageResult {
			MessageId: string;
			MD5OfMessageBody: string;
			MD5OfMessageAttributes: string;
		}

		export interface ReceiveMessageResult {
			Messages: Message[];
		}

		export interface Message {
			MessageId: string;
			ReceiptHandle: string;
			MD5OfBody: string;
			Body: string;
			Attributes: { [name:string]:any };
			MD5OfMessageAttributes:string;
			MessageAttributes: { [name:string]: MessageAttribute; }
		}

		export interface MessageAttribute {
			StringValue?: string;
			BinaryValue?: any; //(Buffer, Typed Array, Blob, String)
			StringListValues?: string[];
			BinaryListValues?: any[];
			DataType: string;
		}

		export interface DeleteMessageBatchResult {
			Successful: DeleteMessageBatchResultEntry[];
			Failed: BatchResultErrorEntry[];
		}

		export interface DeleteMessageBatchResultEntry {
			Id: string;
		}

		export interface BatchResultErrorEntry {
			Id: string;
			Code: string;
			Message?: string;
			SenderFault: boolean;
		}

		export interface SendMessageBatchResult {
			Successful: SendMessageBatchResultEntry[];
			Failed: BatchResultErrorEntry[];
		}

		export interface SendMessageBatchResultEntry {
			Id: string;
			MessageId: string;
			MD5OfMessageBody: string;
			MD5OfMessageAttributes:string;
		}

		export interface CreateQueueResult {
			QueueUrl: string;
		}

		export interface SetQueueAttributesParams {
			QueueUrl: string;
			Attributes: QueueAttributes;
		}

	}

	export module Ses {

		export interface Client {
			config: ClientConfig;

			sendEmail(params: any, callback: (err: any, data: SendEmailResult) => void): void;
		}

		export interface SendEmailRequest {
			Source: string;
			Destination: Destination;
			Message: Message;
			ReplyToAddresses: string[];
			ReturnPath: string;
		}

		export class Destination {
			ToAddresses: string[];
			CcAddresses: string[];
			BccAddresses: string[];
		}

		export class Message {
			Subject: Content;
			Body: Body;
		}

		export class Content {
			Data: string;
			Charset: string;
		}

		export class Body {
			Text: Content;
			Html: Content;
		}

		export class SendEmailResult {
			MessageId: string;
		}

	}

	export module Swf {

		export class Client {
			//constructor(options?: any);
			public config: ClientConfig;

			countClosedWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
			countOpenWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
			countPendingActivityTasks(params: any, callback: (err: any, data: any) => void): void;
			countPendingDecisionTasks(params: any, callback: (err: any, data: any) => void): void;
			deprecateActivityType(params: any, callback: (err: any, data: any) => void): void;
			deprecateDomain(params: any, callback: (err: any, data: any) => void): void;
			deprecateWorkflowType(params: any, callback: (err: any, data: any) => void): void;
			describeActivityType(params: any, callback: (err: any, data: any) => void): void;
			describeDomain(params: any, callback: (err: any, data: any) => void): void;
			describeWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
			describeWorkflowType(params: any, callback: (err: any, data: any) => void): void;
			getWorkflowExecutionHistory(params: any, callback: (err: any, data: any) => void): void;
			listActivityTypes(params: any, callback: (err: any, data: any) => void): void;
			listClosedWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
			listDomains(params: any, callback: (err: any, data: any) => void): void;
			listOpenWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
			listWorkflowTypes(params: any, callback: (err: any, data: any) => void): void;
			pollForActivityTask(params: any, callback: (err: any, data: ActivityTask) => void): void;
			pollForDecisionTask(params: any, callback: (err: any, data: DecisionTask) => void): void;
			recordActivityTaskHeartbeat(params: any, callback: (err: any, data: any) => void): void;
			registerActivityType(params: any, callback: (err: any, data: any) => void): void;
			registerDomain(params: any, callback: (err: any, data: any) => void): void;
			registerWorkflowType(params: any, callback: (err: any, data: any) => void): void;
			requestCancelWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
			respondActivityTaskCanceled(params: RespondActivityTaskCanceledRequest, callback: (err: any, data: any) => void): void;
			respondActivityTaskCompleted(params: RespondActivityTaskCompletedRequest, callback: (err: any, data: any) => void): void;
			respondActivityTaskFailed(params: RespondActivityTaskFailedRequest, callback: (err: any, data: any) => void): void;
			respondDecisionTaskCompleted(params: RespondDecisionTaskCompletedRequest, callback: (err: any, data: any) => void): void;
			signalWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
			startWorkflowExecution(params: any, callback: (err: any, data: StartWorkflowExecutionResult) => void): void;
			terminateWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
		}

		export interface PollForActivityTaskRequest {
			domain?: string;
			taskList?: TaskList;
			identity?: string;
		}

		export interface TaskList {
			name?: string;
		}

		export interface PollForDecisionTaskRequest {
			domain?: string;
			taskList?: TaskList;
			identity?: string;
			nextPageToken?: string;
			maximumPageSize?: number;
			reverseOrder?: Boolean;
		}

		export interface StartWorkflowExecutionRequest {
			domain?: string;
			workflowId?: string;
			workflowType?: WorkflowType;
			taskList?: TaskList;
			input?: string;
			executionStartToCloseTimeout?: string;
			tagList?: string[];
			taskStartToCloseTimeout?: string;
			childPolicy?: string;
		}

		export interface WorkflowType {
			name?: string;
			version?: string;
		}

		export interface RespondDecisionTaskCompletedRequest {
			taskToken?: string;
			decisions?: Decision[];
			executionContext?: string;
		}

		export interface Decision {
			decisionType?: string;
			scheduleActivityTaskDecisionAttributes?: ScheduleActivityTaskDecisionAttributes;
			requestCancelActivityTaskDecisionAttributes?: RequestCancelActivityTaskDecisionAttributes;
			completeWorkflowExecutionDecisionAttributes?: CompleteWorkflowExecutionDecisionAttributes;
			failWorkflowExecutionDecisionAttributes?: FailWorkflowExecutionDecisionAttributes;
			cancelWorkflowExecutionDecisionAttributes?: CancelWorkflowExecutionDecisionAttributes;
			continueAsNewWorkflowExecutionDecisionAttributes?: ContinueAsNewWorkflowExecutionDecisionAttributes;
			recordMarkerDecisionAttributes?: RecordMarkerDecisionAttributes;
			startTimerDecisionAttributes?: StartTimerDecisionAttributes;
			cancelTimerDecisionAttributes?: CancelTimerDecisionAttributes;
			signalExternalWorkflowExecutionDecisionAttributes?: SignalExternalWorkflowExecutionDecisionAttributes;
			requestCancelExternalWorkflowExecutionDecisionAttributes?: RequestCancelExternalWorkflowExecutionDecisionAttributes;
			startChildWorkflowExecutionDecisionAttributes?: StartChildWorkflowExecutionDecisionAttributes;
		}

		export interface ScheduleActivityTaskDecisionAttributes {
			activityType?: ActivityType;
			activityId?: string;
			control?: string;
			input?: string;
			scheduleToCloseTimeout?: string;
			taskList?: TaskList;
			scheduleToStartTimeout?: string;
			startToCloseTimeout?: string;
			heartbeatTimeout?: string;
		}

		export interface ActivityType {
			name?: string;
			version?: string;
		}

		export interface RequestCancelActivityTaskDecisionAttributes {
			activityId?: string;
		}

		export interface CompleteWorkflowExecutionDecisionAttributes {
			result?: string;
		}

		export interface FailWorkflowExecutionDecisionAttributes {
			reason?: string;
			details?: string;
		}

		export interface CancelWorkflowExecutionDecisionAttributes {
			details?: string;
		}

		export interface ContinueAsNewWorkflowExecutionDecisionAttributes {
			input?: string;
			executionStartToCloseTimeout?: string;
			taskList?: TaskList;
			taskStartToCloseTimeout?: string;
			childPolicy?: string;
			tagList?: string[];
			workflowTypeVersion?: string;
		}

		export interface RecordMarkerDecisionAttributes {
			markerName?: string;
			details?: string;
		}

		export interface StartTimerDecisionAttributes {
			timerId?: string;
			control?: string;
			startToFireTimeout?: string;
		}

		export interface CancelTimerDecisionAttributes {
			timerId?: string;
		}

		export interface SignalExternalWorkflowExecutionDecisionAttributes {
			workflowId?: string;
			runId?: string;
			signalName?: string;
			input?: string;
			control?: string;
		}

		export interface RequestCancelExternalWorkflowExecutionDecisionAttributes {
			workflowId?: string;
			runId?: string;
			control?: string;
		}

		export interface StartChildWorkflowExecutionDecisionAttributes {
			workflowType?: WorkflowType;
			workflowId?: string;
			control?: string;
			input?: string;
			executionStartToCloseTimeout?: string;
			taskList?: TaskList;
			taskStartToCloseTimeout?: string;
			childPolicy?: string;
			tagList?: string[];
		}

		export interface RespondActivityTaskCompletedRequest {
			taskToken?: string;
			result?: string;
		}

		export interface RespondActivityTaskFailedRequest {
			taskToken?: string;
			reason?: string;
			details?: string;
		}

		export interface RespondActivityTaskCanceledRequest {
			taskToken?: string;
			details?: string;
		}

		export interface DecisionTask {
			taskToken?: string;
			startedEventId?: number;
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			events?: HistoryEvent[];
			nextPageToken?: string;
			previousStartedEventId?: number;
		}

		export interface WorkflowExecution {
			workflowId?: string;
			runId?: string;
		}

		export interface HistoryEvent {
			eventTimestamp?: any;
			eventType?: string;
			eventId?: number;
			workflowExecutionStartedEventAttributes?: WorkflowExecutionStartedEventAttributes;
			workflowExecutionCompletedEventAttributes?: WorkflowExecutionCompletedEventAttributes;
			completeWorkflowExecutionFailedEventAttributes?: CompleteWorkflowExecutionFailedEventAttributes;
			workflowExecutionFailedEventAttributes?: WorkflowExecutionFailedEventAttributes;
			failWorkflowExecutionFailedEventAttributes?: FailWorkflowExecutionFailedEventAttributes;
			workflowExecutionTimedOutEventAttributes?: WorkflowExecutionTimedOutEventAttributes;
			workflowExecutionCanceledEventAttributes?: WorkflowExecutionCanceledEventAttributes;
			cancelWorkflowExecutionFailedEventAttributes?: CancelWorkflowExecutionFailedEventAttributes;
			workflowExecutionContinuedAsNewEventAttributes?: WorkflowExecutionContinuedAsNewEventAttributes;
			continueAsNewWorkflowExecutionFailedEventAttributes?: ContinueAsNewWorkflowExecutionFailedEventAttributes;
			workflowExecutionTerminatedEventAttributes?: WorkflowExecutionTerminatedEventAttributes;
			workflowExecutionCancelRequestedEventAttributes?: WorkflowExecutionCancelRequestedEventAttributes;
			decisionTaskScheduledEventAttributes?: DecisionTaskScheduledEventAttributes;
			decisionTaskStartedEventAttributes?: DecisionTaskStartedEventAttributes;
			decisionTaskCompletedEventAttributes?: DecisionTaskCompletedEventAttributes;
			decisionTaskTimedOutEventAttributes?: DecisionTaskTimedOutEventAttributes;
			activityTaskScheduledEventAttributes?: ActivityTaskScheduledEventAttributes;
			activityTaskStartedEventAttributes?: ActivityTaskStartedEventAttributes;
			activityTaskCompletedEventAttributes?: ActivityTaskCompletedEventAttributes;
			activityTaskFailedEventAttributes?: ActivityTaskFailedEventAttributes;
			activityTaskTimedOutEventAttributes?: ActivityTaskTimedOutEventAttributes;
			activityTaskCanceledEventAttributes?: ActivityTaskCanceledEventAttributes;
			activityTaskCancelRequestedEventAttributes?: ActivityTaskCancelRequestedEventAttributes;
			workflowExecutionSignaledEventAttributes?: WorkflowExecutionSignaledEventAttributes;
			markerRecordedEventAttributes?: MarkerRecordedEventAttributes;
			timerStartedEventAttributes?: TimerStartedEventAttributes;
			timerFiredEventAttributes?: TimerFiredEventAttributes;
			timerCanceledEventAttributes?: TimerCanceledEventAttributes;
			startChildWorkflowExecutionInitiatedEventAttributes?: StartChildWorkflowExecutionInitiatedEventAttributes;
			childWorkflowExecutionStartedEventAttributes?: ChildWorkflowExecutionStartedEventAttributes;
			childWorkflowExecutionCompletedEventAttributes?: ChildWorkflowExecutionCompletedEventAttributes;
			childWorkflowExecutionFailedEventAttributes?: ChildWorkflowExecutionFailedEventAttributes;
			childWorkflowExecutionTimedOutEventAttributes?: ChildWorkflowExecutionTimedOutEventAttributes;
			childWorkflowExecutionCanceledEventAttributes?: ChildWorkflowExecutionCanceledEventAttributes;
			childWorkflowExecutionTerminatedEventAttributes?: ChildWorkflowExecutionTerminatedEventAttributes;
			signalExternalWorkflowExecutionInitiatedEventAttributes?: SignalExternalWorkflowExecutionInitiatedEventAttributes;
			externalWorkflowExecutionSignaledEventAttributes?: ExternalWorkflowExecutionSignaledEventAttributes;
			signalExternalWorkflowExecutionFailedEventAttributes?: SignalExternalWorkflowExecutionFailedEventAttributes;
			externalWorkflowExecutionCancelRequestedEventAttributes?: ExternalWorkflowExecutionCancelRequestedEventAttributes;
			requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: RequestCancelExternalWorkflowExecutionInitiatedEventAttributes;
			requestCancelExternalWorkflowExecutionFailedEventAttributes?: RequestCancelExternalWorkflowExecutionFailedEventAttributes;
			scheduleActivityTaskFailedEventAttributes?: ScheduleActivityTaskFailedEventAttributes;
			requestCancelActivityTaskFailedEventAttributes?: RequestCancelActivityTaskFailedEventAttributes;
			startTimerFailedEventAttributes?: StartTimerFailedEventAttributes;
			cancelTimerFailedEventAttributes?: CancelTimerFailedEventAttributes;
			startChildWorkflowExecutionFailedEventAttributes?: StartChildWorkflowExecutionFailedEventAttributes;
		}

		export interface WorkflowExecutionStartedEventAttributes {
			input?: string;
			executionStartToCloseTimeout?: string;
			taskStartToCloseTimeout?: string;
			childPolicy?: string;
			taskList?: TaskList;
			workflowType?: WorkflowType;
			tagList?: string[];
			continuedExecutionRunId?: string;
			parentWorkflowExecution?: WorkflowExecution;
			parentInitiatedEventId?: number;
		}

		export interface WorkflowExecutionCompletedEventAttributes {
			result?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface CompleteWorkflowExecutionFailedEventAttributes {
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface WorkflowExecutionFailedEventAttributes {
			reason?: string;
			details?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface FailWorkflowExecutionFailedEventAttributes {
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface WorkflowExecutionTimedOutEventAttributes {
			timeoutType?: string;
			childPolicy?: string;
		}

		export interface WorkflowExecutionCanceledEventAttributes {
			details?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface CancelWorkflowExecutionFailedEventAttributes {
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface WorkflowExecutionContinuedAsNewEventAttributes {
			input?: string;
			decisionTaskCompletedEventId?: number;
			newExecutionRunId?: string;
			executionStartToCloseTimeout?: string;
			taskList?: TaskList;
			taskStartToCloseTimeout?: string;
			childPolicy?: string;
			tagList?: string[];
			workflowType?: WorkflowType;
		}

		export interface ContinueAsNewWorkflowExecutionFailedEventAttributes {
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface WorkflowExecutionTerminatedEventAttributes {
			reason?: string;
			details?: string;
			childPolicy?: string;
			cause?: string;
		}

		export interface WorkflowExecutionCancelRequestedEventAttributes {
			externalWorkflowExecution?: WorkflowExecution;
			externalInitiatedEventId?: number;
			cause?: string;
		}

		export interface DecisionTaskScheduledEventAttributes {
			taskList?: TaskList;
			startToCloseTimeout?: string;
		}

		export interface DecisionTaskStartedEventAttributes {
			identity?: string;
			scheduledEventId?: number;
		}

		export interface DecisionTaskCompletedEventAttributes {
			executionContext?: string;
			scheduledEventId?: number;
			startedEventId?: number;
		}

		export interface DecisionTaskTimedOutEventAttributes {
			timeoutType?: string;
			scheduledEventId?: number;
			startedEventId?: number;
		}

		export interface ActivityTaskScheduledEventAttributes {
			activityType?: ActivityType;
			activityId?: string;
			input?: string;
			control?: string;
			scheduleToStartTimeout?: string;
			scheduleToCloseTimeout?: string;
			startToCloseTimeout?: string;
			taskList?: TaskList;
			decisionTaskCompletedEventId?: number;
			heartbeatTimeout?: string;
		}

		export interface ActivityTaskStartedEventAttributes {
			identity?: string;
			scheduledEventId?: number;
		}

		export interface ActivityTaskCompletedEventAttributes {
			result?: string;
			scheduledEventId?: number;
			startedEventId?: number;
		}

		export interface ActivityTaskFailedEventAttributes {
			reason?: string;
			details?: string;
			scheduledEventId?: number;
			startedEventId?: number;
		}

		export interface ActivityTaskTimedOutEventAttributes {
			timeoutType?: string;
			scheduledEventId?: number;
			startedEventId?: number;
			details?: string;
		}

		export interface ActivityTaskCanceledEventAttributes {
			details?: string;
			scheduledEventId?: number;
			startedEventId?: number;
			latestCancelRequestedEventId?: number;
		}

		export interface ActivityTaskCancelRequestedEventAttributes {
			decisionTaskCompletedEventId?: number;
			activityId?: string;
		}

		export interface WorkflowExecutionSignaledEventAttributes {
			signalName?: string;
			input?: string;
			externalWorkflowExecution?: WorkflowExecution;
			externalInitiatedEventId?: number;
		}

		export interface MarkerRecordedEventAttributes {
			markerName?: string;
			details?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface TimerStartedEventAttributes {
			timerId?: string;
			control?: string;
			startToFireTimeout?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface TimerFiredEventAttributes {
			timerId?: string;
			startedEventId?: number;
		}

		export interface TimerCanceledEventAttributes {
			timerId?: string;
			startedEventId?: number;
			decisionTaskCompletedEventId?: number;
		}

		export interface StartChildWorkflowExecutionInitiatedEventAttributes {
			workflowId?: string;
			workflowType?: WorkflowType;
			control?: string;
			input?: string;
			executionStartToCloseTimeout?: string;
			taskList?: TaskList;
			decisionTaskCompletedEventId?: number;
			childPolicy?: string;
			taskStartToCloseTimeout?: string;
			tagList?: string[];
		}

		export interface ChildWorkflowExecutionStartedEventAttributes {
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			initiatedEventId?: number;
		}

		export interface ChildWorkflowExecutionCompletedEventAttributes {
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			result?: string;
			initiatedEventId?: number;
			startedEventId?: number;
		}

		export interface ChildWorkflowExecutionFailedEventAttributes {
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			reason?: string;
			details?: string;
			initiatedEventId?: number;
			startedEventId?: number;
		}

		export interface ChildWorkflowExecutionTimedOutEventAttributes {
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			timeoutType?: string;
			initiatedEventId?: number;
			startedEventId?: number;
		}

		export interface ChildWorkflowExecutionCanceledEventAttributes {
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			details?: string;
			initiatedEventId?: number;
			startedEventId?: number;
		}

		export interface ChildWorkflowExecutionTerminatedEventAttributes {
			workflowExecution?: WorkflowExecution;
			workflowType?: WorkflowType;
			initiatedEventId?: number;
			startedEventId?: number;
		}

		export interface SignalExternalWorkflowExecutionInitiatedEventAttributes {
			workflowId?: string;
			runId?: string;
			signalName?: string;
			input?: string;
			decisionTaskCompletedEventId?: number;
			control?: string;
		}

		export interface ExternalWorkflowExecutionSignaledEventAttributes {
			workflowExecution?: WorkflowExecution;
			initiatedEventId?: number;
		}

		export interface SignalExternalWorkflowExecutionFailedEventAttributes {
			workflowId?: string;
			runId?: string;
			cause?: string;
			initiatedEventId?: number;
			decisionTaskCompletedEventId?: number;
			control?: string;
		}

		export interface ExternalWorkflowExecutionCancelRequestedEventAttributes {
			workflowExecution?: WorkflowExecution;
			initiatedEventId?: number;
		}

		export interface RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
			workflowId?: string;
			runId?: string;
			decisionTaskCompletedEventId?: number;
			control?: string;
		}

		export interface RequestCancelExternalWorkflowExecutionFailedEventAttributes {
			workflowId?: string;
			runId?: string;
			cause?: string;
			initiatedEventId?: number;
			decisionTaskCompletedEventId?: number;
			control?: string;
		}

		export interface ScheduleActivityTaskFailedEventAttributes {
			activityType?: ActivityType;
			activityId?: string;
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface RequestCancelActivityTaskFailedEventAttributes {
			activityId?: string;
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface StartTimerFailedEventAttributes {
			timerId?: string;
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface CancelTimerFailedEventAttributes {
			timerId?: string;
			cause?: string;
			decisionTaskCompletedEventId?: number;
		}

		export interface StartChildWorkflowExecutionFailedEventAttributes {
			workflowType?: WorkflowType;
			cause?: string;
			workflowId?: string;
			initiatedEventId?: number;
			decisionTaskCompletedEventId?: number;
			control?: string;
		}

		export interface ActivityTask {
			taskToken?: string;
			activityId?: string;
			startedEventId?: number;
			workflowExecution?: WorkflowExecution;
			activityType?: ActivityType;
			input?: string;
		}

		export interface PollForActivityTaskResult {
			activityTask?: ActivityTask;
		}

		export interface PollForDecisionTaskResult {
			decisionTask?: DecisionTask;
		}

		export interface StartWorkflowExecutionResult {
			run?: Run;
		}

		export interface Run {
			runId?: string;
		}

	}

	export module Sns {

		export interface Client {
			config: ClientConfig;

			publicTopic(params: PublishRequest, callback: (err: any, data: PublishResult) => void): void;
			createTopic(params: CreateTopicRequest, callback: (err: any, data: CreateTopicResult) => void): void;
			deleteTopic(params: DeleteTopicRequest, callback: (err: any, data: any) => void): void;
		}

		export interface PublishRequest {
			TopicArn?: string;
			Message?: string;
			MessageStructure?: string;
			Subject?: string;
		}

		export interface PublishResult {
			MessageId?: string;
		}

		export interface CreateTopicRequest {
			Name?: string;
		}

		export interface CreateTopicResult {
			TopicArn?: string;
		}

		export interface DeleteTopicRequest {
			TopicArn?: string;
		}

	}

	export module s3 {

		export interface PutObjectRequest {
			ACL?: string;
			Body?: any;
			Bucket: string;
			CacheControl?: string;
			ContentDisposition?: string;
			ContentEncoding?: string;
			ContentLanguage?: string;
			ContentLength?: string;
			ContentMD5?: string;
			ContentType?: string;
			Expires?: any;
			GrantFullControl?: string;
			GrantRead?: string;
			GrantReadACP?: string;
			GrantWriteACP?: string;
			Key: string;
			Metadata?: string[];
			ServerSideEncryption?: string;
			StorageClass?: string;
			WebsiteRedirectLocation?: string;
		}

		export interface GetObjectRequest {
			Bucket: string;
			IfMatch?: string;
			IfModifiedSince?: any;
			IfNoneMatch?: string;
			IfUnmodifiedSince?: any;
			Key: string;
			Range?: string;
			ResponseCacheControl?: string;
			ResponseContentDisposition?: string;
			ResponseContentEncoding?: string;
			ResponseContentLanguage?: string;
			ResponseContentType?: string;
			ResponseExpires?: any;
			VersionId?: string;
		}

	}

	export module ecs {
		export interface CreateServicesParams {
			desiredCount: number;
			serviceName: string;
			taskDefinition: string;
			clientToken?: string;
			cluster?: string;
			deploymentConfiguration?: {
				maximumPercent?: number;
				minimumHealthyPercent?: number;
			};
			loadBalancers?: {
				containerName?: string;
				containerPort?: number;
				loadBalancerName?: string;
			}[];
			role?: string;
		}

		export interface DescribeServicesParams {
			services: string[];
			cluster: string;
		}

		export interface DescribeTaskDefinitionParams {
			taskDefinition: string;
		}

		export interface RegisterTaskDefinitionParams {
			containerDefinitions: {
				command?: string[],
				cpu?: number,
				disableNetworking?: boolean,
				dnsSearchDomains?: string[],
				dnsServers?: string[],
				dockerLabels?: any,
				dockerSecurityOptions?: string[],
				entryPoint?: string[],
				environment?: any[],
				essential?: boolean,
				extraHosts?: {
					hostName: string,
					ipAddress: string
				}[];
				hostname?: string,
				image?: string,
				links?: string[],
				logConfiguration?: {
					logDriver: string,
					options: any
				}[],
				memory?: number,
				mountPoints?: {
					containerPath: string,
					readOnly: boolean,
					sourceVolume: string
				}[];
				name?: string,
				portMappings?: {
					containerPort?: number,
					hostPort?: number,
					protocol: string
				}[];
				privileged?: boolean,
				readonlyRootFilesystem?: boolean,
				ulimits?: {
					hardLimit: number,
					name: string,
					softLimit: number
				}[];
				user?: string,
				volumesFrom?: {
					readOnly?: boolean,
					sourceContainer?: string
				}[],
				workingDirectory?: string
			}[];
			family: string;
			volumes?: {
				host: {
					sourcePath: string
				},
				name: string
			}[];
		}

		export interface UpdateServiceParams {
			service: string;
			cluster?: string;
			deploymentConfiguration?: {
				maximumPercent: number;
				minimumHealthyPercent: number;
			};
			desiredCount?: number;
			taskDefinition: string;
		}
	}
}